// Fireblocks API
//
// Fireblocks provides a suite of applications to manage digital asset operations and a complete development platform to build your business on the blockchain.  - Visit our website for more information: [Fireblocks Website](https://fireblocks.com) - Visit our developer docs: [Fireblocks DevPortal](https://developers.fireblocks.com)
//
// The version of the OpenAPI document: 1.8.0
// Contact: developers@fireblocks.com
// Generated by: https://openapi-generator.tech

use {
    crate::models,
    serde::{Deserialize, Serialize},
};

/// PolicyRule : Policy rule which is enforced on transactions
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct PolicyRule {
    /// (deprecated - replaced by \"operators\")  | Defines users who can
    /// initiate the type of transaction to which the rule applies. options are
    /// * \"*\" - All users are allowed * Specific User id
    #[serde(rename = "operator", skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(rename = "operators", skip_serializing_if = "Option::is_none")]
    pub operators: Option<models::PolicyRuleOperators>,
    /// Defines the type of transaction to which the rule applies.   * TRANSFER
    /// - Default. Transfers funds from one account to another   * CONTRACT_CALL
    /// - Calls a smart contract, mainly for DeFi operations.   * PROGRAM_CALL -
    /// Calls a smart contract for web3 operations on the Solana blockchain.
    /// * APPROVE - Allows a smart contract to withdraw from a designated
    /// wallet.   * MINT - Perform a mint operation (increase supply) on a
    /// supported token   * BURN - Perform a burn operation (reduce supply) on a
    /// supported token   * SUPPLY - Use for DeFi to lend assets   * REDEEM -
    /// Use for DeFi to get lending back   * STAKE - Allows you to allocate and
    /// lock certain assets for earning staking rewards.   * RAW - An off-chain
    /// message with no predefined format, use it to sign any message with your
    /// private key.   * TYPED_MESSAGE - An off-chain message type that follows
    /// a predefined format, used to sign specific messages that are not actual
    /// transactions.
    #[serde(rename = "transactionType", skip_serializing_if = "Option::is_none")]
    pub transaction_type: Option<TransactionType>,
    /// (deprecated - replaced by \"designatedSigners\") Id representing the
    /// user who signs transactions that match a specific rule
    #[serde(rename = "designatedSigner", skip_serializing_if = "Option::is_none")]
    pub designated_signer: Option<String>,
    #[serde(rename = "designatedSigners", skip_serializing_if = "Option::is_none")]
    pub designated_signers: Option<models::PolicyRuleDesignatedSigners>,
    /// Policy rule type
    #[serde(rename = "type")]
    pub r#type: Type,
    /// Defines what occurs when a transaction meets the rule's criteria * ALLOW
    /// - The transaction goes through and can be signed without requiring
    /// additional approvals * BLOCK - The transaction is automatically blocked
    /// * 2-TIER - Only these users or user groups can approve             If
    /// any of them reject the transaction before the required approval
    /// threshold is met, the transaction doesn't go through            The list
    /// of entities are set is \"authorizationGroups\" field
    #[serde(rename = "action")]
    pub action: Action,
    /// Defines the type of asset being transacted, options are * \"*\" - All
    /// assets * Specific asset
    #[serde(rename = "asset")]
    pub asset: String,
    /// (deprecated - replaced by \"src\") source account type
    #[serde(rename = "srcType", skip_serializing_if = "Option::is_none")]
    pub src_type: Option<models::PolicySrcOrDestType>,
    /// (deprecated - replaced by \"src\") source sub account type
    #[serde(rename = "srcSubType", skip_serializing_if = "Option::is_none")]
    pub src_sub_type: Option<models::PolicySrcOrDestSubType>,
    /// (deprecated - replaced by \"src\") source account id
    #[serde(rename = "srcId", skip_serializing_if = "Option::is_none")]
    pub src_id: Option<String>,
    #[serde(rename = "src", skip_serializing_if = "Option::is_none")]
    pub src: Option<models::PolicyRuleSrc>,
    /// (deprecated - replaced by \"dst\") destination account type
    #[serde(rename = "dstType", skip_serializing_if = "Option::is_none")]
    pub dst_type: Option<models::PolicySrcOrDestType>,
    /// (deprecated - replaced by \"dst\") destination sub account type
    #[serde(rename = "dstSubType", skip_serializing_if = "Option::is_none")]
    pub dst_sub_type: Option<models::PolicySrcOrDestSubType>,
    /// (deprecated - replaced by \"dst\") destination account id
    #[serde(rename = "dstId", skip_serializing_if = "Option::is_none")]
    pub dst_id: Option<String>,
    #[serde(rename = "dst", skip_serializing_if = "Option::is_none")]
    pub dst: Option<models::PolicyRuleDst>,
    /// Defines whether the destination to which you are sending funds must be
    /// whitelisted, to allow one-time transfers to non-whitelisted external
    /// addresses, or both. By default, you can only transfer to an external
    /// address after it’s whitelisted.   * WHITELISTED - Can only be sent to
    /// whitelisted addresses.   * ONE_TIME - Can only be sent to
    /// non-whitelisted external addresses.   * \"*\" - can be sent to
    /// whitelisted addresses or non-whitelisted external
    #[serde(rename = "dstAddressType", skip_serializing_if = "Option::is_none")]
    pub dst_address_type: Option<DstAddressType>,
    /// * USD - Limits the amount of any asset users can transfer based on the
    ///   USD equivalent of the asset. * EUR - Limits the amount of any asset
    ///   users can transfer based on the EURO equivalent of the asset. * NATIVE
    ///   - Limits the amount of an asset a user can transfer when using a
    ///   specific asset.
    #[serde(rename = "amountCurrency")]
    pub amount_currency: AmountCurrency,
    /// * SINGLE_TX - limit applies to a single transaction * TIMEFRAME - limit
    ///   applies to all transactions within the defined time period
    #[serde(rename = "amountScope")]
    pub amount_scope: AmountScope,
    #[serde(rename = "amount")]
    pub amount: models::PolicyRuleAmount,
    /// Time period in seconds applied by the amountScope field to accumulate
    /// transferred amounts in transactions that match the rule, until the total
    /// exceeds the value you specify under Minimum. When the specified amount
    /// is reached within that period, whether by one or many transactions,
    /// further transactions in that period either fail or require more
    /// approvals.
    #[serde(rename = "periodSec")]
    pub period_sec: f64,
    /// (deprecated - replaced by \"authorizationGroups\") Allowed entities
    /// which can approves a transaction
    #[serde(rename = "authorizers", skip_serializing_if = "Option::is_none")]
    pub authorizers: Option<Vec<String>>,
    /// (deprecated - replaced by \"authorizationGroups\") Min amount of
    /// entities which are needed to approve a transaction
    #[serde(rename = "authorizersCount", skip_serializing_if = "Option::is_none")]
    pub authorizers_count: Option<f64>,
    #[serde(
        rename = "authorizationGroups",
        skip_serializing_if = "Option::is_none"
    )]
    pub authorization_groups: Option<models::PolicyRuleAuthorizationGroups>,
    #[serde(rename = "amountAggregation", skip_serializing_if = "Option::is_none")]
    pub amount_aggregation: Option<models::PolicyRuleAmountAggregation>,
    #[serde(rename = "rawMessageSigning", skip_serializing_if = "Option::is_none")]
    pub raw_message_signing: Option<models::PolicyRuleRawMessageSigning>,
    /// Applying this rule over APPROVE type transactions (can only be enabled
    /// when rule's transaction type is TRANSFER)
    #[serde(rename = "applyForApprove", skip_serializing_if = "Option::is_none")]
    pub apply_for_approve: Option<bool>,
    /// Applying this rule over TYPED_MESSAGE type transactions (can only be
    /// enabled when rule's transaction type is CONTRACT_CALL)
    #[serde(
        rename = "applyForTypedMessage",
        skip_serializing_if = "Option::is_none"
    )]
    pub apply_for_typed_message: Option<bool>,
    /// A unique id identifying the rule
    #[serde(rename = "externalDescriptor", skip_serializing_if = "Option::is_none")]
    pub external_descriptor: Option<String>,
}

impl PolicyRule {
    /// Policy rule which is enforced on transactions
    pub fn new(
        r#type: Type,
        action: Action,
        asset: String,
        amount_currency: AmountCurrency,
        amount_scope: AmountScope,
        amount: models::PolicyRuleAmount,
        period_sec: f64,
    ) -> PolicyRule {
        PolicyRule {
            operator: None,
            operators: None,
            transaction_type: None,
            designated_signer: None,
            designated_signers: None,
            r#type,
            action,
            asset,
            src_type: None,
            src_sub_type: None,
            src_id: None,
            src: None,
            dst_type: None,
            dst_sub_type: None,
            dst_id: None,
            dst: None,
            dst_address_type: None,
            amount_currency,
            amount_scope,
            amount,
            period_sec,
            authorizers: None,
            authorizers_count: None,
            authorization_groups: None,
            amount_aggregation: None,
            raw_message_signing: None,
            apply_for_approve: None,
            apply_for_typed_message: None,
            external_descriptor: None,
        }
    }
}
/// Defines the type of transaction to which the rule applies.   * TRANSFER -
/// Default. Transfers funds from one account to another   * CONTRACT_CALL -
/// Calls a smart contract, mainly for DeFi operations.   * PROGRAM_CALL - Calls
/// a smart contract for web3 operations on the Solana blockchain.    * APPROVE
/// - Allows a smart contract to withdraw from a designated wallet.   * MINT -
/// Perform a mint operation (increase supply) on a supported token   * BURN -
/// Perform a burn operation (reduce supply) on a supported token   * SUPPLY -
/// Use for DeFi to lend assets   * REDEEM - Use for DeFi to get lending back
/// * STAKE - Allows you to allocate and lock certain assets for earning staking
/// rewards.   * RAW - An off-chain message with no predefined format, use it to
/// sign any message with your private key.   * TYPED_MESSAGE - An off-chain
/// message type that follows a predefined format, used to sign specific
/// messages that are not actual transactions.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum TransactionType {
    #[serde(rename = "TRANSFER")]
    Transfer,
    #[serde(rename = "CONTRACT_CALL")]
    ContractCall,
    #[serde(rename = "PROGRAM_CALL")]
    ProgramCall,
    #[serde(rename = "APPROVE")]
    Approve,
    #[serde(rename = "MINT")]
    Mint,
    #[serde(rename = "BURN")]
    Burn,
    #[serde(rename = "SUPPLY")]
    Supply,
    #[serde(rename = "REDEEM")]
    Redeem,
    #[serde(rename = "STAKE")]
    Stake,
    #[serde(rename = "RAW")]
    Raw,
    #[serde(rename = "TYPED_MESSAGE")]
    TypedMessage,
}

impl Default for TransactionType {
    fn default() -> TransactionType {
        Self::Transfer
    }
}
/// Policy rule type
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Type {
    #[serde(rename = "TRANSFER")]
    Transfer,
}

impl Default for Type {
    fn default() -> Type {
        Self::Transfer
    }
}
/// Defines what occurs when a transaction meets the rule's criteria * ALLOW -
/// The transaction goes through and can be signed without requiring additional
/// approvals * BLOCK - The transaction is automatically blocked * 2-TIER - Only
/// these users or user groups can approve             If any of them reject the
/// transaction before the required approval threshold is met, the transaction
/// doesn't go through            The list of entities are set is
/// \"authorizationGroups\" field
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Action {
    #[serde(rename = "ALLOW")]
    Allow,
    #[serde(rename = "BLOCK")]
    Block,
    #[serde(rename = "2-TIER")]
    Variant2Tier,
}

impl Default for Action {
    fn default() -> Action {
        Self::Allow
    }
}
/// Defines whether the destination to which you are sending funds must be
/// whitelisted, to allow one-time transfers to non-whitelisted external
/// addresses, or both. By default, you can only transfer to an external address
/// after it’s whitelisted.   * WHITELISTED - Can only be sent to whitelisted
/// addresses.   * ONE_TIME - Can only be sent to non-whitelisted external
/// addresses.   * \"*\" - can be sent to whitelisted addresses or
/// non-whitelisted external
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum DstAddressType {
    #[serde(rename = "WHITELISTED")]
    Whitelisted,
    #[serde(rename = "ONE_TIME")]
    OneTime,
    #[serde(rename = "*")]
    Star,
}

impl Default for DstAddressType {
    fn default() -> DstAddressType {
        Self::Whitelisted
    }
}
/// * USD - Limits the amount of any asset users can transfer based on the USD
///   equivalent of the asset. * EUR - Limits the amount of any asset users can
///   transfer based on the EURO equivalent of the asset. * NATIVE - Limits the
///   amount of an asset a user can transfer when using a specific asset.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum AmountCurrency {
    #[serde(rename = "USD")]
    Usd,
    #[serde(rename = "EUR")]
    Eur,
    #[serde(rename = "NATIVE")]
    Native,
}

impl Default for AmountCurrency {
    fn default() -> AmountCurrency {
        Self::Usd
    }
}
/// * SINGLE_TX - limit applies to a single transaction * TIMEFRAME - limit
///   applies to all transactions within the defined time period
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum AmountScope {
    #[serde(rename = "SINGLE_TX")]
    SingleTx,
    #[serde(rename = "TIMEFRAME")]
    Timeframe,
}

impl Default for AmountScope {
    fn default() -> AmountScope {
        Self::SingleTx
    }
}
